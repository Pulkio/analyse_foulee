accel_total = sqrt(accel_data$dv1^2 + accel_data$dv2^2 + accel_data$accel_z_corrected^2),
vel_total = cumsum(accel_data$accel_total * delta_t),
speed = signal::savgol(vel_total, 51, 3, deriv = 1) # Appliquer un filtre de Savitzky-Golay pour lisser la courbe de vitesse et obtenir la vitesse instantanée
)
library(dplyr)
library(ggplot2)
library(pracma)
library(data.table)
library(lubridate)
library(signal)
library(wavethresh)
accel_data <- fread("../data/test6.csv", header=TRUE, sep=",", dec=".")
colnames(accel_data)[colnames(accel_data) == "dv[1]"] <- "dv1"
colnames(accel_data)[colnames(accel_data) == "dv[2]"] <- "dv2"
colnames(accel_data)[colnames(accel_data) == "dv[3]"] <- "dv3"
# Calculer le temps en minutes
accel_data$time <- accel_data$PacketCounter / 60
# a ignorer
#accel_data <- read.csv("../data/test1.csv", header = TRUE, skip =11)
#colnames(accel_data)[colnames(accel_data) == "dv.1."] <- "dv1"
#colnames(accel_data)[colnames(accel_data) == "dv.2."] <- "dv2"
#colnames(accel_data)[colnames(accel_data) == "dv.3."] <- "dv3"
#accel_data <- select(accel_data, dv1, dv2, dv3, time, dq_W, dq_X, dq_Y, dq_Z)
#accel_data <- select(accel_data, dv1, dv2, dv3, time, dq_W, dq_X, dq_Y, dq_Z)
# fin de a ignorer
# Calculer la composante d'accélération gravitationnelle le long de l'axe z car correspond à l'axe le plus impacté
#par la gravité
g <- mean(accel_data$dv3)
# Enlever la composante d'accélération gravitationnelle des données d'accélération le long de l'axe z
accel_data <- mutate(accel_data, accel_z_corrected = accel_data$dv3 - g)
# Calculer le temps entre les échantillons en secondes
delta_t <- 1/60
# Calculer la vitesse instantanée le long des axes x, y et z en intégrant deux fois l'accélération
accel_data <- mutate(accel_data,
vel_x = cumsum(accel_data$dv1 * delta_t),
vel_y = cumsum(accel_data$dv2 * delta_t),
vel_z = cumsum(accel_data$accel_z_corrected * delta_t))
# Calculer l'accélération instantanée le long des axes x, y et z en dérivant la vitesse
accel_data <- mutate(accel_data,
accel_x = c(0, diff(accel_data$vel_x)) / delta_t,
accel_y = c(0, diff(accel_data$vel_y)) / delta_t,
accel_z = c(0, diff(accel_data$vel_z)) / delta_t)
# Calculer la déviation totale le long des axes x, y et z en intégrant l'accélération
accel_data <- mutate(accel_data,
disp_x = cumsum(cumsum(accel_data$accel_x) * delta_t^2),
disp_y = cumsum(cumsum(accel_data$accel_y) * delta_t^2),
disp_z = cumsum(cumsum(accel_data$accel_z) * delta_t^2))
# Calculer la vitesse instantanée de déplacement du coureur en utilisant les données d'accélération
accel_data <- mutate(accel_data,
accel_total = sqrt(accel_data$dv1^2 + accel_data$dv2^2 + accel_data$accel_z_corrected^2),
vel_total = cumsum(accel_data$accel_total * delta_t),
speed = signal::savgol(vel_total, 51, 3, deriv = 1) # Appliquer un filtre de Savitzky-Golay pour lisser la courbe de vitesse et obtenir la vitesse instantanée
)
library(dplyr)
library(ggplot2)
library(pracma)
library(data.table)
library(lubridate)
library(signal)
library(wavethresh)
accel_data <- fread("../data/test6.csv", header=TRUE, sep=",", dec=".")
colnames(accel_data)[colnames(accel_data) == "dv[1]"] <- "dv1"
colnames(accel_data)[colnames(accel_data) == "dv[2]"] <- "dv2"
colnames(accel_data)[colnames(accel_data) == "dv[3]"] <- "dv3"
# Calculer le temps en minutes
accel_data$time <- accel_data$PacketCounter / 60
# a ignorer
#accel_data <- read.csv("../data/test1.csv", header = TRUE, skip =11)
#colnames(accel_data)[colnames(accel_data) == "dv.1."] <- "dv1"
#colnames(accel_data)[colnames(accel_data) == "dv.2."] <- "dv2"
#colnames(accel_data)[colnames(accel_data) == "dv.3."] <- "dv3"
#accel_data <- select(accel_data, dv1, dv2, dv3, time, dq_W, dq_X, dq_Y, dq_Z)
#accel_data <- select(accel_data, dv1, dv2, dv3, time, dq_W, dq_X, dq_Y, dq_Z)
# fin de a ignorer
# Calculer la composante d'accélération gravitationnelle le long de l'axe z car correspond à l'axe le plus impacté
#par la gravité
g <- mean(accel_data$dv3)
# Enlever la composante d'accélération gravitationnelle des données d'accélération le long de l'axe z
accel_data <- mutate(accel_data, accel_z_corrected = accel_data$dv3 - g)
# Calculer le temps entre les échantillons en secondes
delta_t <- 1/60
# Calculer la vitesse instantanée le long des axes x, y et z en intégrant deux fois l'accélération
accel_data <- mutate(accel_data,
vel_x = cumsum(accel_data$dv1 * delta_t),
vel_y = cumsum(accel_data$dv2 * delta_t),
vel_z = cumsum(accel_data$accel_z_corrected * delta_t))
# Calculer l'accélération instantanée le long des axes x, y et z en dérivant la vitesse
accel_data <- mutate(accel_data,
accel_x = c(0, diff(accel_data$vel_x)) / delta_t,
accel_y = c(0, diff(accel_data$vel_y)) / delta_t,
accel_z = c(0, diff(accel_data$vel_z)) / delta_t)
# Calculer la déviation totale le long des axes x, y et z en intégrant l'accélération
accel_data <- mutate(accel_data,
disp_x = cumsum(cumsum(accel_data$accel_x) * delta_t^2),
disp_y = cumsum(cumsum(accel_data$accel_y) * delta_t^2),
disp_z = cumsum(cumsum(accel_data$accel_z) * delta_t^2))
# Calculer la vitesse instantanée de déplacement du coureur en utilisant les données d'accélération
accel_data <- mutate(accel_data,
accel_total = sqrt(accel_data$dv1^2 + accel_data$dv2^2 + accel_data$accel_z_corrected^2),
vel_total = cumsum(accel_data$accel_total * delta_t),
speed = signal::savgol(vel_total, 51, 3, deriv = 1) # Appliquer un filtre de Savitzky-Golay pour lisser la courbe de vitesse et obtenir la vitesse instantanée
)
# Calculer la vitesse instantanée de déplacement du coureur en utilisant les données d'accélération
accel_data <- mutate(accel_data, accel_total = sqrt(accel_data$dv1^2 + accel_data$dv2^2 + accel_data$accel_z_corrected^2))
View(accel_data)
vel_total = cumsum(accel_data$accel_total * delta_t)
library(dplyr)
library(ggplot2)
library(pracma)
library(data.table)
library(lubridate)
library(signal)
library(wavethresh)
accel_data <- fread("../data/test6.csv", header=TRUE, sep=",", dec=".")
colnames(accel_data)[colnames(accel_data) == "dv[1]"] <- "dv1"
colnames(accel_data)[colnames(accel_data) == "dv[2]"] <- "dv2"
colnames(accel_data)[colnames(accel_data) == "dv[3]"] <- "dv3"
# Calculer le temps en minutes
accel_data$time <- accel_data$PacketCounter / 60
# a ignorer
#accel_data <- read.csv("../data/test1.csv", header = TRUE, skip =11)
#colnames(accel_data)[colnames(accel_data) == "dv.1."] <- "dv1"
#colnames(accel_data)[colnames(accel_data) == "dv.2."] <- "dv2"
#colnames(accel_data)[colnames(accel_data) == "dv.3."] <- "dv3"
#accel_data <- select(accel_data, dv1, dv2, dv3, time, dq_W, dq_X, dq_Y, dq_Z)
#accel_data <- select(accel_data, dv1, dv2, dv3, time, dq_W, dq_X, dq_Y, dq_Z)
# fin de a ignorer
# Calculer la composante d'accélération gravitationnelle le long de l'axe z car correspond à l'axe le plus impacté
#par la gravité
g <- mean(accel_data$dv3)
# Enlever la composante d'accélération gravitationnelle des données d'accélération le long de l'axe z
accel_data <- mutate(accel_data, accel_z_corrected = accel_data$dv3 - g)
# Calculer le temps entre les échantillons en secondes
delta_t <- 1/60
# Calculer la vitesse instantanée le long des axes x, y et z en intégrant deux fois l'accélération
accel_data <- mutate(accel_data,
vel_x = cumsum(accel_data$dv1 * delta_t),
vel_y = cumsum(accel_data$dv2 * delta_t),
vel_z = cumsum(accel_data$accel_z_corrected * delta_t))
# Calculer l'accélération instantanée le long des axes x, y et z en dérivant la vitesse
accel_data <- mutate(accel_data,
accel_x = c(0, diff(accel_data$vel_x)) / delta_t,
accel_y = c(0, diff(accel_data$vel_y)) / delta_t,
accel_z = c(0, diff(accel_data$vel_z)) / delta_t)
# Calculer la déviation totale le long des axes x, y et z en intégrant l'accélération
accel_data <- mutate(accel_data,
disp_x = cumsum(cumsum(accel_data$accel_x) * delta_t^2),
disp_y = cumsum(cumsum(accel_data$accel_y) * delta_t^2),
disp_z = cumsum(cumsum(accel_data$accel_z) * delta_t^2))
# Calculer la vitesse instantanée de déplacement du coureur en utilisant les données d'accélération
accel_data <- mutate(accel_data, accel_total = sqrt(accel_data$dv1^2 + accel_data$dv2^2 + accel_data$accel_z_corrected^2))
accel_data <- mutate(accel_data, vel_total = cumsum(accel_data$accel_total * delta_t))
library(dplyr)
library(ggplot2)
library(pracma)
library(data.table)
library(lubridate)
library(signal)
library(wavethresh)
accel_data <- fread("../data/test6.csv", header=TRUE, sep=",", dec=".")
colnames(accel_data)[colnames(accel_data) == "dv[1]"] <- "dv1"
colnames(accel_data)[colnames(accel_data) == "dv[2]"] <- "dv2"
colnames(accel_data)[colnames(accel_data) == "dv[3]"] <- "dv3"
# Calculer le temps en minutes
accel_data$time <- accel_data$PacketCounter / 60
# a ignorer
#accel_data <- read.csv("../data/test1.csv", header = TRUE, skip =11)
#colnames(accel_data)[colnames(accel_data) == "dv.1."] <- "dv1"
#colnames(accel_data)[colnames(accel_data) == "dv.2."] <- "dv2"
#colnames(accel_data)[colnames(accel_data) == "dv.3."] <- "dv3"
#accel_data <- select(accel_data, dv1, dv2, dv3, time, dq_W, dq_X, dq_Y, dq_Z)
#accel_data <- select(accel_data, dv1, dv2, dv3, time, dq_W, dq_X, dq_Y, dq_Z)
# fin de a ignorer
# Calculer la composante d'accélération gravitationnelle le long de l'axe z car correspond à l'axe le plus impacté
#par la gravité
g <- mean(accel_data$dv3)
# Enlever la composante d'accélération gravitationnelle des données d'accélération le long de l'axe z
accel_data <- mutate(accel_data, accel_z_corrected = accel_data$dv3 - g)
# Calculer le temps entre les échantillons en secondes
delta_t <- 1/60
# Calculer la vitesse instantanée le long des axes x, y et z en intégrant deux fois l'accélération
accel_data <- mutate(accel_data,
vel_x = cumsum(accel_data$dv1 * delta_t),
vel_y = cumsum(accel_data$dv2 * delta_t),
vel_z = cumsum(accel_data$accel_z_corrected * delta_t))
# Calculer l'accélération instantanée le long des axes x, y et z en dérivant la vitesse
accel_data <- mutate(accel_data,
accel_x = c(0, diff(accel_data$vel_x)) / delta_t,
accel_y = c(0, diff(accel_data$vel_y)) / delta_t,
accel_z = c(0, diff(accel_data$vel_z)) / delta_t)
# Calculer la déviation totale le long des axes x, y et z en intégrant l'accélération
accel_data <- mutate(accel_data,
disp_x = cumsum(cumsum(accel_data$accel_x) * delta_t^2),
disp_y = cumsum(cumsum(accel_data$accel_y) * delta_t^2),
disp_z = cumsum(cumsum(accel_data$accel_z) * delta_t^2))
# Calculer la vitesse instantanée de déplacement du coureur en utilisant les données d'accélération
accel_data <- mutate(accel_data, accel_total = sqrt(accel_data$dv1^2 + accel_data$dv2^2 + accel_data$accel_z_corrected^2))
accel_data <- mutate(accel_data, vel_total = cumsum(accel_data$accel_total * delta_t))
accel_data <- mutate(accel_data, speed = signal::savgol(vel_total, 51, 3, deriv = 1)) # Appliquer un filtre de Savitzky-Golay pour lisser la courbe de vitesse et obtenir la vitesse instantanée
library(dplyr)
library(ggplot2)
library(pracma)
library(data.table)
library(lubridate)
library(signal)
library(wavethresh)
accel_data <- fread("../data/test6.csv", header=TRUE, sep=",", dec=".")
colnames(accel_data)[colnames(accel_data) == "dv[1]"] <- "dv1"
colnames(accel_data)[colnames(accel_data) == "dv[2]"] <- "dv2"
colnames(accel_data)[colnames(accel_data) == "dv[3]"] <- "dv3"
# Calculer le temps en minutes
accel_data$time <- accel_data$PacketCounter / 60
# a ignorer
#accel_data <- read.csv("../data/test1.csv", header = TRUE, skip =11)
#colnames(accel_data)[colnames(accel_data) == "dv.1."] <- "dv1"
#colnames(accel_data)[colnames(accel_data) == "dv.2."] <- "dv2"
#colnames(accel_data)[colnames(accel_data) == "dv.3."] <- "dv3"
#accel_data <- select(accel_data, dv1, dv2, dv3, time, dq_W, dq_X, dq_Y, dq_Z)
#accel_data <- select(accel_data, dv1, dv2, dv3, time, dq_W, dq_X, dq_Y, dq_Z)
# fin de a ignorer
# Calculer la composante d'accélération gravitationnelle le long de l'axe z car correspond à l'axe le plus impacté
#par la gravité
g <- mean(accel_data$dv3)
# Enlever la composante d'accélération gravitationnelle des données d'accélération le long de l'axe z
accel_data <- mutate(accel_data, accel_z_corrected = accel_data$dv3 - g)
# Calculer le temps entre les échantillons en secondes
delta_t <- 1/60
# Calculer la vitesse instantanée le long des axes x, y et z en intégrant deux fois l'accélération
accel_data <- mutate(accel_data,
vel_x = cumsum(accel_data$dv1 * delta_t),
vel_y = cumsum(accel_data$dv2 * delta_t),
vel_z = cumsum(accel_data$accel_z_corrected * delta_t))
# Calculer l'accélération instantanée le long des axes x, y et z en dérivant la vitesse
accel_data <- mutate(accel_data,
accel_x = c(0, diff(accel_data$vel_x)) / delta_t,
accel_y = c(0, diff(accel_data$vel_y)) / delta_t,
accel_z = c(0, diff(accel_data$vel_z)) / delta_t)
# Calculer la déviation totale le long des axes x, y et z en intégrant l'accélération
accel_data <- mutate(accel_data,
disp_x = cumsum(cumsum(accel_data$accel_x) * delta_t^2),
disp_y = cumsum(cumsum(accel_data$accel_y) * delta_t^2),
disp_z = cumsum(cumsum(accel_data$accel_z) * delta_t^2))
# Calculer la vitesse instantanée de déplacement du coureur en utilisant les données d'accélération
accel_data <- mutate(accel_data, accel_total = sqrt(accel_data$dv1^2 + accel_data$dv2^2 + accel_data$accel_z_corrected^2))
accel_data <- mutate(accel_data, vel_total = cumsum(accel_data$accel_total * delta_t))
accel_data <- mutate(accel_data, speed = smooth.spline(accel_data$time, accel_data$vel_total, spar = 0.8)$y) # Appliquer un filtre de lissage avec smooth.spline pour obtenir la vitesse instantanée
# Tracer la courbe de la vitesse instantanée totale en fonction du temps
ggplot(accel_data, aes(x = time, y = speed)) +
geom_line() +
xlab("Temps (minutes)") +
ylab("Vitesse instantanée de déplacement (m/s)")
library(dplyr)
library(ggplot2)
library(pracma)
library(data.table)
library(lubridate)
library(signal)
library(wavethresh)
accel_data <- read.csv("../data/test1.csv", header = TRUE, skip =11)
colnames(accel_data)[colnames(accel_data) == "dv.1."] <- "dv1"
colnames(accel_data)[colnames(accel_data) == "dv.2."] <- "dv2"
colnames(accel_data)[colnames(accel_data) == "dv.3."] <- "dv3"
View(accel_data)
library(dplyr)
library(ggplot2)
library(pracma)
library(data.table)
library(lubridate)
library(signal)
library(wavethresh)
accel_data <- read.csv("../data/test1.csv", header = TRUE, skip =11)
colnames(accel_data)[colnames(accel_data) == "dv.1."] <- "dv1"
colnames(accel_data)[colnames(accel_data) == "dv.2."] <- "dv2"
colnames(accel_data)[colnames(accel_data) == "dv.3."] <- "dv3"
# Calculer la composante d'accélération gravitationnelle le long de l'axe z car correspond à l'axe le plus impacté
#par la gravité
g <- mean(accel_data$dv3)
# Enlever la composante d'accélération gravitationnelle des données d'accélération le long de l'axe z
accel_data <- mutate(accel_data, accel_z_corrected = accel_data$dv3 - g)
library(dplyr)
library(ggplot2)
library(pracma)
library(data.table)
library(lubridate)
library(signal)
library(wavethresh)
accel_data <- read.csv("../data/test1.csv", header = TRUE, skip =11)
colnames(accel_data)[colnames(accel_data) == "dv.1."] <- "dv1"
colnames(accel_data)[colnames(accel_data) == "dv.2."] <- "dv2"
colnames(accel_data)[colnames(accel_data) == "dv.3."] <- "dv3"
accel_data$time <- accel_data$PacketCounter / 60
# Calculer la composante d'accélération gravitationnelle le long de l'axe z car correspond à l'axe le plus impacté
#par la gravité
g <- mean(accel_data$dv3)
# Enlever la composante d'accélération gravitationnelle des données d'accélération le long de l'axe z
accel_data <- mutate(accel_data, accel_z_corrected = accel_data$dv3 - g)
library(ggplot2)
library(pracma)
accel_data <- read.csv("../data/test1.csv", header = TRUE, skip =11)
colnames(accel_data)[colnames(accel_data) == "dv.1."] <- "dv1"
colnames(accel_data)[colnames(accel_data) == "dv.2."] <- "dv2"
colnames(accel_data)[colnames(accel_data) == "dv.3."] <- "dv3"
accel_data$time <- accel_data$PacketCounter / 60
# Calculer la composante d'accélération gravitationnelle le long de l'axe z car correspond à l'axe le plus impacté
#par la gravité
g <- mean(accel_data$dv3)
# Enlever la composante d'accélération gravitationnelle des données d'accélération le long de l'axe z
accel_data <- mutate(accel_data, accel_z_corrected = accel_data$dv3 - g)
library(ggplot2)
library(pracma)
accel_data <- read.csv("../data/test1.csv", header = TRUE, skip =11)
colnames(accel_data)[colnames(accel_data) == "dv.1."] <- "dv1"
colnames(accel_data)[colnames(accel_data) == "dv.2."] <- "dv2"
colnames(accel_data)[colnames(accel_data) == "dv.3."] <- "dv3"
accel_data$time <- accel_data$PacketCounter / 60
# Calculer la composante d'accélération gravitationnelle le long de l'axe z car correspond à l'axe le plus impacté
#par la gravité
g <- mean(accel_data$dv3)
# Enlever la composante d'accélération gravitationnelle des données d'accélération le long de l'axe z
accel_data <- mutate(accel_data, accel_z_corrected = accel_data$dv3 - g)
ggplot(data, aes(x = accel_z_corrected, y = time)) +
geom_line(color = "blue") +
xlab("Accélération en z") +
ylab("Temps")
library(ggplot2)
library(pracma)
accel_data <- read.csv("../data/test1.csv", header = TRUE, skip =11)
colnames(accel_data)[colnames(accel_data) == "dv.1."] <- "dv1"
colnames(accel_data)[colnames(accel_data) == "dv.2."] <- "dv2"
colnames(accel_data)[colnames(accel_data) == "dv.3."] <- "dv3"
accel_data$time <- accel_data$PacketCounter / 60
# Calculer la composante d'accélération gravitationnelle le long de l'axe z car correspond à l'axe le plus impacté
#par la gravité
g <- mean(accel_data$dv3)
# Enlever la composante d'accélération gravitationnelle des données d'accélération le long de l'axe z
accel_data <- mutate(accel_data, accel_z_corrected = accel_data$dv3 - g)
ggplot(data, aes(x = accel_data$accel_z_corrected, y = accel_data$time)) +
geom_line(color = "blue") +
xlab("Accélération en z") +
ylab("Temps")
library(ggplot2)
library(pracma)
accel_data <- read.csv("../data/test1.csv", header = TRUE, skip =11)
colnames(accel_data)[colnames(accel_data) == "dv.1."] <- "dv1"
colnames(accel_data)[colnames(accel_data) == "dv.2."] <- "dv2"
colnames(accel_data)[colnames(accel_data) == "dv.3."] <- "dv3"
accel_data$time <- accel_data$PacketCounter / 60
# Calculer la composante d'accélération gravitationnelle le long de l'axe z car correspond à l'axe le plus impacté
#par la gravité
g <- mean(accel_data$dv3)
# Enlever la composante d'accélération gravitationnelle des données d'accélération le long de l'axe z
accel_data <- mutate(accel_data, accel_z_corrected = accel_data$dv3 - g)
ggplot(accel_data, aes(x = accel_data$accel_z_corrected, y = accel_data$time)) +
geom_line(color = "blue") +
xlab("Accélération en z") +
ylab("Temps")
library(ggplot2)
library(pracma)
accel_data <- read.csv("../data/test1.csv", header = TRUE, skip =11)
colnames(accel_data)[colnames(accel_data) == "dv.1."] <- "dv1"
colnames(accel_data)[colnames(accel_data) == "dv.2."] <- "dv2"
colnames(accel_data)[colnames(accel_data) == "dv.3."] <- "dv3"
accel_data$time <- accel_data$PacketCounter / 60
# Calculer la composante d'accélération gravitationnelle le long de l'axe z car correspond à l'axe le plus impacté
#par la gravité
g <- mean(accel_data$dv3)
# Enlever la composante d'accélération gravitationnelle des données d'accélération le long de l'axe z
accel_data <- mutate(accel_data, accel_z_corrected = accel_data$dv3 - g)
ggplot(accel_data, aes(x = accel_z_corrected, y = time)) +
geom_line(color = "blue") +
xlab("Accélération en z") +
ylab("Temps")
library(ggplot2)
library(pracma)
accel_data <- read.csv("../data/test1.csv", header = TRUE, skip =11)
colnames(accel_data)[colnames(accel_data) == "dv.1."] <- "dv1"
colnames(accel_data)[colnames(accel_data) == "dv.2."] <- "dv2"
colnames(accel_data)[colnames(accel_data) == "dv.3."] <- "dv3"
accel_data$time <- accel_data$PacketCounter / 60
# Calculer la composante d'accélération gravitationnelle le long de l'axe z car correspond à l'axe le plus impacté
#par la gravité
g <- mean(accel_data$dv3)
# Enlever la composante d'accélération gravitationnelle des données d'accélération le long de l'axe z
accel_data <- mutate(accel_data, accel_z_corrected = accel_data$dv3 - g)
ggplot(accel_data, aes(x = accel_z_corrected, y = time)) +
geom_line(color = "blue") +
xlab("Accélération en z") +
ylab("Temps")
library(ggplot2)
library(pracma)
accel_data <- read.csv("../data/test1.csv", header = TRUE, skip =11)
colnames(accel_data)[colnames(accel_data) == "dv.1."] <- "dv1"
colnames(accel_data)[colnames(accel_data) == "dv.2."] <- "dv2"
colnames(accel_data)[colnames(accel_data) == "dv.3."] <- "dv3"
accel_data$time <- accel_data$PacketCounter / 60
# Calculer la composante d'accélération gravitationnelle le long de l'axe z car correspond à l'axe le plus impacté
#par la gravité
g <- mean(accel_data$dv3)
# Enlever la composante d'accélération gravitationnelle des données d'accélération le long de l'axe z
accel_data <- mutate(accel_data, accel_z_corrected = accel_data$dv3 - g)
ggplot(accel_data, aes(x = time, y = accel_z_corrected)) +
geom_line(color = "blue") +
xlab("Accélération en z") +
ylab("Temps")
library(ggplot2)
library(pracma)
accel_data <- read.csv("../data/test1.csv", header = TRUE, skip =11)
colnames(accel_data)[colnames(accel_data) == "dv.1."] <- "dv1"
colnames(accel_data)[colnames(accel_data) == "dv.2."] <- "dv2"
colnames(accel_data)[colnames(accel_data) == "dv.3."] <- "dv3"
accel_data$time <- accel_data$PacketCounter / 60
# Calculer la composante d'accélération gravitationnelle le long de l'axe z car correspond à l'axe le plus impacté
#par la gravité
g <- mean(accel_data$dv3)
# Enlever la composante d'accélération gravitationnelle des données d'accélération le long de l'axe z
accel_data <- mutate(accel_data, accel_z_corrected = accel_data$dv3 - g)
ggplot(accel_data, aes(x = time, y = accel_z_corrected)) +
geom_line(color = "blue") +
xlab("Accélération en z") +
ylab("Temps")
# Filtrer les données en ne gardant que celles où time > 7
data_filtered <- subset(data, time > 7)
library(ggplot2)
library(pracma)
accel_data <- read.csv("../data/test1.csv", header = TRUE, skip =11)
colnames(accel_data)[colnames(accel_data) == "dv.1."] <- "dv1"
colnames(accel_data)[colnames(accel_data) == "dv.2."] <- "dv2"
colnames(accel_data)[colnames(accel_data) == "dv.3."] <- "dv3"
accel_data$time <- accel_data$PacketCounter / 60
# Calculer la composante d'accélération gravitationnelle le long de l'axe z car correspond à l'axe le plus impacté
#par la gravité
g <- mean(accel_data$dv3)
# Enlever la composante d'accélération gravitationnelle des données d'accélération le long de l'axe z
accel_data <- mutate(accel_data, accel_z_corrected = accel_data$dv3 - g)
ggplot(accel_data, aes(x = time, y = accel_z_corrected)) +
geom_line(color = "blue") +
xlab("Accélération en z") +
ylab("Temps")
# Filtrer les données en ne gardant que celles où time > 7
data_filtered <- subset(data, time > 7)
library(ggplot2)
library(pracma)
accel_data <- read.csv("../data/test1.csv", header = TRUE, skip =11)
colnames(accel_data)[colnames(accel_data) == "dv.1."] <- "dv1"
colnames(accel_data)[colnames(accel_data) == "dv.2."] <- "dv2"
colnames(accel_data)[colnames(accel_data) == "dv.3."] <- "dv3"
accel_data$time <- accel_data$PacketCounter / 60
# Calculer la composante d'accélération gravitationnelle le long de l'axe z car correspond à l'axe le plus impacté
#par la gravité
g <- mean(accel_data$dv3)
# Enlever la composante d'accélération gravitationnelle des données d'accélération le long de l'axe z
accel_data <- mutate(accel_data, accel_z_corrected = accel_data$dv3 - g)
ggplot(accel_data, aes(x = time, y = accel_z_corrected)) +
geom_line(color = "blue") +
xlab("Accélération en z") +
ylab("Temps")
# Filtrer les données en ne gardant que celles où time > 7
data_filtered <- subset(accel_data, time > 7)
ggplot(data_filtered, aes(x = time, y = accel_z_corrected)) +
geom_line(color = "red") +
xlab("Accélération en z") +
ylab("Temps")
View(data_filtered)
# Extraire la colonne accel_z_corrected
accel_z <- data_filtered$accel_z_corrected
# Normaliser la colonne accel_z_corrected
accel_z_norm <- scale(accel_z)
# Appliquer l'algorithme de clustering hiérarchique avec 3 clusters
clust <- hclust(dist(accel_z_norm))
groups <- cutree(clust, k = 3)
# Visualiser les groupes obtenus avec des couleurs différentes
plot(accel_z_norm, col = groups, pch = 20, main = "Clustering des accélérations en z")
legend("topright", legend = paste("Groupe", 1:3), col = 1:3, pch = 20)
library(ggplot2)
library(pracma)
accel_data <- read.csv("../data/test1.csv", header = TRUE, skip =11)
colnames(accel_data)[colnames(accel_data) == "dv.1."] <- "dv1"
colnames(accel_data)[colnames(accel_data) == "dv.2."] <- "dv2"
colnames(accel_data)[colnames(accel_data) == "dv.3."] <- "dv3"
accel_data$time <- accel_data$PacketCounter / 60
# Calculer la composante d'accélération gravitationnelle le long de l'axe z car correspond à l'axe le plus impacté
#par la gravité
g <- mean(accel_data$dv3)
# Enlever la composante d'accélération gravitationnelle des données d'accélération le long de l'axe z
accel_data <- mutate(accel_data, accel_z_corrected = accel_data$dv3 - g)
ggplot(accel_data, aes(x = time, y = accel_z_corrected)) +
geom_line(color = "blue") +
xlab("Accélération en z") +
ylab("Temps")
# Filtrer les données en ne gardant que celles où time > 7
data_filtered <- subset(accel_data, time > 7)
ggplot(data_filtered, aes(x = time, y = accel_z_corrected)) +
geom_line(color = "red") +
xlab("Accélération en z") +
ylab("Temps")
# Extraire la colonne accel_z_corrected
accel_z <- data_filtered$accel_z_corrected
# Normaliser la colonne accel_z_corrected
accel_z_norm <- scale(accel_z)
# Calculer la transformée de Fourier de la colonne accel_z_corrected
fft_z <- fft(accel_z_norm)
fft_z_abs <- abs(fft_z)
fft_z_abs[1] <- 0  # supprimer la composante DC
# Extraire les fréquences dominantes
freqs <- seq(0, length(fft_z_abs)-1)
peak_freqs <- freqs[fft_z_abs > quantile(fft_z_abs, 0.95)]
# Appliquer l'algorithme de clustering spectral aux fréquences dominantes
library(RWeka)
install.packages("RWeka")
library(ggplot2)
library(pracma)
library(RWeka)
